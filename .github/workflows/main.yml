name: Video Transcode Workflow
on:
  push:
  pull_request:
  workflow_dispatch:

jobs:
  setup-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      hash: ${{ steps.download.outputs.hash }}
    steps:
      - name: Setup Dependencies
        run: |
          pip3 install xdcc-dl pika psutil
          sudo apt install wget

      - name: Fetch ffmpeg
        run: |
          url=`
              curl -s https://api.github.com/repos/BtbN/FFmpeg-Builds/releases/latest \
              | grep "linux64-gpl.tar.xz" \
              | cut -d : -f 2,3 \
              | cut -d , -f 2 \
              | tr -d \" 
              | tr -d ' '
          `
          wget -O ffmpeg.tar.xz $url 
          tar -xvf ffmpeg.tar.xz

      - name: Download
        id: download
        env:
          RABBITMQ_URL: ${{ secrets.RABBITMQ_URL }}
        shell: python
        run: |
          import os
          import sys
          import json
          import pika
          import hashlib
          from xdcc_dl.xdcc import download_packs
          from xdcc_dl.entities import XDCCPack, IrcServer

          params = pika.URLParameters(os.environ['RABBITMQ_URL'])
          connection = pika.BlockingConnection(params)

          channel = connection.channel()
          channel.queue_declare(queue='dl')

          method_frame, header_frame, body = channel.basic_get('dl')

          if body is not None:
              print(" [x] Received %r" % body.decode())
              data = json.loads(body.decode())
              print(" [x] Validating Pack ")
              pack = XDCCPack(IrcServer("irc.rizon.net"), data["bot"], data["pack"])
              # Validate pack
              print(pack)
              print(" [x] Success! Sending Acknowledgement ")
              channel.basic_ack(method_frame.delivery_tag)
              print(" [x] Downloading... ")
              pack.set_filename("output", True)
              download_packs([pack])
              print(" [x] Download Done ")
              print(" [x] Done ")
          else:
              print("No message received")
              sys.exit(1)

          filename = "output.mkv"
          with open(filename,"rb") as f:
              bytes = f.read() 
              readable_hash = hashlib.sha256(bytes).hexdigest();
              print(readable_hash)

          print("::set-output name=hash::" + readable_hash)

      - name: Segment Video
        run: |
          mkdir ./pre
          DURATION=$(ffprobe -i output.mkv -show_format -v quiet | sed -n 's/duration=//p')
          SEGMENT_SIZE=$(bc <<< "scale=0; $DURATION / 128.0")

          echo "Duration: $DURATION"
          echo "Size: $SEGMENT_SIZE"

          ./ffmpeg/bin/ffmpeg -i output.mkv \
              -vcodec copy -f segment -segment_time $SEGMENT_SIZE \
              ./pre/pre_%02d.mkv

      - name: Setup Matrix
        id: set-matrix
        shell: python
        run: |
          from os import listdir
          from os.path import isfile, join
          import json

          path = './pre'
          files = [f for f in listdir(path) if isfile(join(path, f))]
          segments = { 'segments': files }

          print("::set-output name=matrix::" + json.dumps(segments))

      - name: Upload to Cache
        uses: actions/cache@v2
        with:
          path: |
            ./pre
          key: ${{ steps.download.outputs.hash }}


  check-matrix:
    runs-on: ubuntu-latest
    needs: setup-matrix
    steps:
      - name: Install json2yaml
        run: |
          sudo npm install -g json2yaml

      - name: Check matrix definition
        run: |
          matrix='${{ needs.setup-matrix.matrix.outputs.matrix }}'
          echo $matrix
          echo $matrix | jq .
          echo $matrix | json2yaml
      
      - name: Check Cache
        shell: python
        run: |
          from os import listdir
          from os.path import isfile, join
          import json

          path = './pre'
          files = [f for f in listdir(path) if isfile(join(path, f))]
          segments = { 'segments': files }
          print(segments)
